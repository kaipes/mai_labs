# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Каширин Кирилл Дмитриевич

## Результат проверки

Вариант задания:

 - [ ] стандартный, без NLP (на 3)
 - [x] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |    4.3           |
| Левинская М.А.|              |               |

> *Парсер заимствован [отсюда](https://github.com/MAILabs-Edu-2021/lp-capstone-Yadroff/). В остальном работа хорошая, необходимо собеседование*

## Введение
До прохождения этого курса в ВУЗе, я изучал императивное программирование. Однако помимо этой парадигмы программирования существует еще множество других парадигм программирования. Одна из них - парадигма логического программирования. Этот курсовой проект как раз нацелен не только на изучение этой парадигмы, но и на практическое применение логического программирования в реальной жизни. В данном курсовом проекте я создам свое генеалогическое древо своей семьи, получу знания об структуре и обработки файлов формата GEDCOM, изучу навыки написания и работы с парсером, а также исследую родство с помощью языка Prolog.

## Задание
1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM, используя сервис MyHeritage.com.
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, с использованием предиката `child(ребенок, родитель)`, `male(человек)`, `female(человек)`.
3. Реализовать предикат проверки/поиска шурина.

## Получение родословного дерева
Я зарегистрировался на сервисе MyHeritage.com , с помощью конструктора семеного дерева, создал своё генеалогическое древо из 45 персон на 4 поколения назад.


## Конвертация родословного дерева
Для конвертации родословоного дерева я выбрал язык Python, поскольку синтаксис этого языка предельно прост и позволяет легко проводить обработку текста.

Принцип действии программы легок. 
Парсер открывает файл формата GEDCOM для чтения. С помощью метода `readlines()` получаем список строк. Закрываем файл и создаем словарь `relatives`, который будет хранить ключем - ID человека и значением - массив, который хранит в себе имя человека, имя его папы, имя его мамы и пол человека.

```python
f = open("tree.ged", "r", encoding='utf-8')
file = f.readlines()
f.close()
relative = {}
```

В цикле построчно обрабатываем кажду строку, с помощью метода `find()` ищем ключевые слова в файле, а именно ID человека, его имя и фамилия и пол. Информация о том, есть ли у человека муж или жена, а также дети хранится после объявления всех людей в файле GEDCOM. Поэтому в этом же цикле мы можем найти по ID муж/жену человека и ID их детей.

```python
for s in file:
    if s.find('INDI') != -1:
        ID = s.split(' ')[1].rstrip()
    elif (s.find('GIVN')) != -1:
        name_and_surname = s.split(' ')[2].rstrip()
    elif s.find('SURN') != -1:
        name_and_surname = name_and_surname + ' ' + s.split(' ')[2].rstrip()
    elif s.find('SEX') != -1:
        if s.split(' ')[2].rstrip() == 'F':
            relative[ID] = [name_and_surname, '-1', '-1', 'female']
        else:
            relative[ID] = [name_and_surname, '-1', '-1', 'male']
    if s.find('HUSB') != -1:
        father = relative[s.split(' ')[2].rstrip()][0]
    elif s.find('WIFE') != -1:
        mother = relative[s.split(' ')[2].rstrip()][0]
    elif s.find('CHIL') != -1:
        relative[s.split(' ')[2].rstrip()][1] = father
        relative[s.split(' ')[2].rstrip()][2] = mother
```

Далее парсер создаёт файл с расширение pl и открывает его на запись. В цикле проходимся по словарю и печатаем сначала факт `child(ребенок, родитель)`, а после `male(человек)`, `female(человек)`. Закрываем файл.

```python
outfile = open("my_tree.pl", "w")
for i in relative:
    if relative[i][1] != '-1':
        outfile.write("child('" + relative[i][0] + "','" + relative[i][1] + "').\n")
    if relative[i][2] != '-1':
        outfile.write("child('" + relative[i][0] + "','" + relative[i][2] + "').\n")
for i in relative:
    if relative[i][3] == 'male':
        outfile.write(relative[i][3] + "('" + relative[i][0] + "').\n")
for i in relative:
    if relative[i][3] == 'female':
        outfile.write(relative[i][3] + "('" + relative[i][0] + "').\n")
outfile.close()
```

## Предикат поиска родственника

Для реализации предикат проверки/поиска шурина я использую предикат `brother-in-law`. В первой строке предиката я проверяю есть ли у жены брат через общего родителей. Во второй строке я проверяю, есть ли у жены муж через их общего ребенка. Далее я проверяю, что найденный человек мужского пола и не является тем, же человеком, что и муж жены.

Реализация:
```prolog
brother_in_law(X, Husband) :-
  child(Wife, Parent), child(X, Parent), 
  child(R, Wife), child(R, Husband), 
  X\= Husband,
  male(X).
```
Примеры использования:
```prolog
?- brother_in_law(X,'Дмитрий Каширин').
X = 'Александр Ветошкин' .

?- brother_in_law(X,'Виктор Ветошкин').
false.

?- brother_in_law('Александр Кузнецов','Александр Ветошкин').
true 
```

## Определение степени родства
Для начала я определяю предикаты определения отношений между людьми, которые близки друг другу (например, мама, отец, муж, жена). Также я определил предикат `check`, который проверяет эти отношения. Пример кода определения и проверки брата:
```prolog
brother(X,Y):-
    child(X,Z),
    child(Y,Z),
    X\=Y,
    male(X).

check(brother,X,Y):-
    brother(X,Y).
```

Для поиска степени родства я использовал дополнительные предикаты для поиска в шрину. Предикат `accordance` переделывает список родственников на соотвествующий список родства с помощью предиката `check`, который делает проверку родства, и предиката `add`, который добавляет в новый список элеента родства.
```prolog
accordance([_],T,T).
accordance([First,Second|Tail],T,R):-
    check(Relation,First,Second),
    add(Relation,T,X),
    accordance([Second|Tail],X,R),!.
```

Чтобы определить степени родства, я реализовал поиск в пространстве состояний, а именно поиск в глубину.
```prolog
search_in_width(X,Y,P):-
    width([[X]],Y,L),
    reverse(L,P).

width([[Finish|T]|_],Finish,[Finish|T]).

width([Next|B],Finish,Ans):-
    findall(X,prolong(Next,X),T),
    append(B,T,Bn),
    width(Bn,Finish,Ans),!.

width([_|T],Finish,Ans):-
    width(T,Finish,Ans).

relative(X, Y, Z):-
    search_in_width(Y, Z, R),!,
    accordance(R,[] ,X).
```
После поиска в глубину, мы получаем список родственников, который с помощью предиката `accordance` переводим в список родства.
Результаты:
```prolog
?- relative(X,'Виктор Ветошкин','Татьяна Игонина').
X = [husband].
(т.е. Виктор Ветошкин является мужем Татьяны Игониной)

?- relative(X,'Виктор Ветошкин','Римма Мохова').
X = [father, husband, sister, husband].
(т.е. Виктор Ветошкин отец мужа сестры мужа Риммы Моховой;
Виктор Ветошкин отец Александра Ветошкина, Александр Ветошкин муж Ирины Кузнецовой,
Ирина Кузнецова сестра Александра Кузнецова, Александр Кузнецов муж Риммы Моховой)

?- relative(X,'Андрей Самохин','Полина Самохина').
X = [brother].
(т.е. Андрей Самохин брат Полины Самохиной)

?- relative(X,'Ксения Качан','Мария Самохина').
X = [mother].
(т.е. Ксения Качан мама Марии Самохиной)
```

## Естественно-языковый интерфейс
Естественно-языковой интерфейс поддерживает три варианта вопросов: How many brothers does Mary have?; Who is Kirill's brother?; Is Helen Kirill's mother?).
C помощью предиката `reduction`, мы сводим множественное число родственной связи к единственному числу. Например:
```prolog
reduction('brothers', 'brother').
```
Также я создал предикаты проверки на корректность введенной фразы. В предикате `member_phrase` происходит проверка, является ли вопрос корректным относительно вопросов языкового-интерфейса. Предикат `member_relative` проверяет корректность родственного названия(брат, сестра, мать и т.д.).
```prolog
member_relative(Relative) :- 
    check(Relative,_,_), !.

member_phrase([Question | Tail], X) :- 
    member(Question,['How many', 'Who is', 'Is']), 
    member_question(Tail, X).
```

Для того, чтобы ответить на вопрос я исследую вопрос и вычленяю из него имена и родственные названия. Для этого я создал предикат `member_question`. На вход этому предикату подаётся вопрос уже без начала (слов How many, Is, Who is).

Рассмотрим предикат `member_question` для вопроса Is. В Head лежит имя, мы делаем проверку этого имена и следующего имени лежащего после Head, есть ли оно в фактах, полученных после парсинга родословного дерева. После этого вычленяем родственное название и делаем проверку на корректность введенного родственного названия. С помощью предиката `append`, создаем список состоящий из двух имен и родственного названия.
```prolog
member_question([Head | Tail], X) :- 
    (male(Head);female(Head)), 
    split(Tail, [Person, "'s" | _], [Person | _]),
    (male(Person);female(Person)),
    member_relative(Relative), !, append([Head], [Person], T), append(T, [Relative], X).
```

Предикат `research` проверяет с помощью предикат `check` на наличие данного факта о том, что оба имени имеют конкретное родственное узло, полученные с предиката `member_question`. И возвращаем true/false в зависимости от наличия факта.
```prolog
research(X, _) :- 
    X = [Person, Person1, Relative], 
    check(Relative, Person, Person1).
```

Для вопроса Who is мы получаем имя и родственное название. И в предикате `research` ищем с помощью предиката `check` ищем человека, которай является родственником человеку, который был получен в предикате `member_question`.
```prolog
member_question([Head | Tail], X) :- 
    (male(Head);female(Head)), 
    split(Tail, _, [Relative | _]), 
    member_relative(Relative), !, append([Head], [Relative], X).
research(X, Y) :- 
    X = [Person, Relationship], 
    check(Relationship, Y, Person).
```

Для вопроса How many также парсим вопрос и вычленяем родственную связь и имя. А предикате `research` создаем список, в котором будут хранится имена, которые удовлетворяют фактам.
```prolog
member_question([Head | Tail], X) :- 
    reduction(Head, Relative), 
    member_relative(Relative), 
    split(Tail, _, [Person | _]),
    (male(Person); female(Person)), !, append([Relative], [Person], X)
research(X, Y) :- 
    X = [Relationship, Person], 
    setof(Z, check(Relationship, Z, Person), List), 
    length(List, Y).
```
Окончательный предикат `answer` содержит в себе предикат проверки корректности вопроса и получение данных и предикат наличие факта.
```prolog
answer(X, Z) :- 
    member_phrase(X, Y), 
    research(Y, Z).
```
Результат:
```prolog
?- answer(['Who is', 'Ирина Кузнецова', "'s", 'father', '?'], X).
X = 'Василий Захаров' .
?- answer(['How many', 'sons', 'does', 'Римма Мохова', 'have', '?'], X).
X = 2 .
?- answer(['Is', 'Елена Ветошкина', 'Кирилл Каширин', "'s", 'mother', '?'], X).
true .
```
## Выводы
Прежде всего данный курсовой проект замотивировал меня узнать более подробно о генеалогическом дереве своей семьи. Теперь я хочу сделать запросы в архивы для того, чтобы создать максимально подробное древо с биографией членов своей семьи. 

С точки зрения программирования курсовой проект помог мне изучить принципы языка Prolog, развить мышление, поскольку к некоторым задачам я приступал под разным углом. Я разобрался с парсером и написал первый парсер текстового файла формата GEDCOM. В курсовом проекте я также применил алгоритм поиска в ширину. Особенно мне понравилось поработать с естественно-языковом интерфейс, где я парсил вопрос и в зависимости от вопроса и искал ответ на него, анализируя факты, полученные из родословного дерева.

Одним из творческих заданий курсового проекта было написание эссе, которое меня заинтересовало в изучении истории создания парадигмы логического программиворания, изучения современных систем логического программирования, о которых я даже не знал, их преимущества и различия каждого, а также о дальнейшем развитии логического программирования, области искусственного интелекта и робототехники.

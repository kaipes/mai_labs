# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Каширин К.Д.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    21/10     |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Список в Prolog является структурой данных, состоящий из узлов. Список является односвязным, т.к. узел хранит в себе одну ссылку на следующий элемент. Элементами списка могут быть любые объекты. Метод обработки списков заключается в следующем: отделить от списка голову, выполнить с ней какие-либо действия и перейти к работе с хвостом списка, являющимся в свою очередь списком. Далее у хвоста списка отделить голову и так далее до тех пор, пока список не останется пустым. 

Список в Prolog можно приблизительно сравнить с массивами в императивных языках, но для списков нет необходимости заранее объявлять размерность. Элемент данных может быть очень быстро добавлен или удален из начала односвязного списка. Однако операция произвольного доступа в списках выполняется гораздо дольше чем в массивах, т.к. требует n операций перехода по ссылкам(для обращения к n-му элементу). Также не все императивные языки имеют такую структуру данных, как список. В языке Prolog нет явной работой с указателями в узлах списка. Ещё одним отличием списков в Prolog от списков в императивных языках в том, что обработка в Prolog возможна только рекурсивно, разделяя список на голову и хвост.

## Задание 1.1: Предикат обработки списка

Стандартные предикаты обработки списков:
```prolog
length([],0).
length([_|Y],N):-length(Y,N1), N is N1+1.

member(A,[A|_]).
member(A,[_|Z]):-member(A,Z).

append([],X,X).
append([A|X],Y,[A|Z]):-append(X,Y,Z).

remove(X,[X|T],T).
remove(X,[Y|T],[Y|T1]):-remove(X,T,T1).

permute([],[]).
permute(L,[X|T]):-remove(X,L,R),permute(R,T).

sublist(S,L):-append(_,L1,L),append(S,_,L1).
```

`function(N, [_|T], X)` - Получение N-го элемента списка, реализация без стандартных предикатов обработки списков.

`function1(N, [_|T], X)` - Получение N-го элемента списка, реализация c стандартными предикатами обработки списков.

Примеры использования:
```prolog
?- function(5,[a,b,c,d,t,g],X).
X = t .
?- function(5,[a,b,c],X).
false.
?- function(3,[a,b,2,4,5],X).
X = 2 .

?- function1(5,[a,b,c,d,t,g],X).
X = t .
?- function1(5,[a,b,c],X).
false.
?- function1(3,[a,b,2,4,5],X).
X = 2 .
```

Реализация:
```prolog
% Реализация без стандартных предикатов обработки списков
function(1, [X|_], X).
function(N, [_|T], X) :- N1 is N - 1, function(N1, T, X).
%Реализация с стандартными предикатами обработки списков
function1(N, L, X) :- append(Y, [X|_], L), N1 is N-1, length(Y, N1).
```

Предикат `function(N, [_|T], X)` рекурсивно обходит с конца список, пока не найдет элемент.
Предикат `function1(N, [_|T], X)` c помощью предиката `append` разбивает искомый список на два списка так, чтобы второй список начинался с N-го элемента списка, т.е. элемента, который нужно получить.

`function2(N, L, X)` -  пример совместного использования предикатов. Переставление N-го элемента в конец списка.

Примеры использования:
```prolog
?- function2(2,[1,2,3,4],T).
T = [1, 3, 4, 2] .

?- function2(4,[a,f,g,t,y],T).
T = [a, f, g, y, t] 
```

Реализация:
```prolog
function2(N,L,Y):-function(N,L,X),remove(X,L,T),append(T,[X],Y).
```

Предикат `function2(N, L, T)` запускает предикат получения N-го элемента списка, с помощью стандартного предиката `remove` удаляет его и происходит конкатенация списка и удаленного элемента с помощью предиката `append`. Таким образом, мы получаем список, в котором элемент, который находился на запрошенной позиции, переставляется в конец списка.

## Задание 1.2: Предикат обработки числового списка

`geom([X,Y,Z|T])` - Проверка списка на геометрическую прогрессию без стандартных предикатов обработки списков.

`geom1([X,Y,Z|T])` - Проверка списка на геометрическую прогрессию c стандартными предикатами обработки списков.

Примеры использования:
```prolog
?- geom([2,4,8,16,32]).
true.
?- geom([2,4,8,14,32]).
false.

?- geom1([2,4,8,16,32]).
true .
?- geom1([2,4,8,14,32]).
false.
```

Реализация:
```prolog
% Реализация без стандартных предикатов обработки списков
geom([X,Y,Z|T]) :-!, (X*Z) =:= (Y*Y), geom([Y,Z|T]).
geom(_).
%Реализация с стандартными предикатами обработки списков
geom1([X,Y,Z|T]) :-!, (X*Z) =:= (Y*Y), remove(X, [X,Y,Z|T], R), geom1(R).
geom1(_).
```

Оба предиката для проверки списка на геометрическую прогрессию используют признак геометрической прогрессии, а именно если для всех членов последовательности, начиная со второго, квадрат члена равен произведению предыдущего и последующего членов последовательности, то последовательность является геометрической прогрессией. Предикат `geom([X,Y,Z|T])` рекурсивно проверяет первые три элемента последовательности и список сдвигается на один элемент вправо. Предикат `geom1([X,Y,Z|T])` проверяет первые три элемента на признак геометрической последовательности, удаляет первый элемент с помощью стандартного предиката обработки списков `remove` и вызывает предикат `geom1([R])`уже для списка, в котором удалили первый элемент списка.

## Задание 2: Реляционное представление данных
Реляционное представление - представление, основанное на отношениях между объектами, такое представление также часто называют табличным. 
Преимущества реляционного представления в удобном хранении информации, а также в отображении данных в достаточно простой и понятной форме. Недостатками реляционного представления данных заключается в том, что не все предментые области можно представить в виде таблиц, таблицы могут занимать относительно много внешней памяти.

В моем варианте представлений данных о студентах(one.pl) отношения представлены таким образом: student(102,'Петров'). subject('LP','Логическое программирование'). grade('Петровский','LP',5).

Данное представление не очень удобное для моего варианта заданий, поскольку при создании списка групп или предметов для учеников дублируются элементы, которые нужно удалить.

**Вариант 1**

**1.Получить таблицу групп и средний балл по каждой из групп**

Для того, чтобы получить таблицу группы и средний балл по каждой из групп, нужно написать вспомогательные предикаты.

`sum([X|Y], S)` - вычисление суммы элементов списка. Разделим список на первый элемент и хвост. Рекурсивно ищем сумму элементов списка с конца. Если список пустой, сумма равна 0.

`average(X,T)` - вычисляет среднее арифметическое значение элементов списка. С помощью предиката `length` находим длину списка, а предикат `sum` находит сумму элементов списка. Поделив, находим среднее арифметическое значение элементов списка.

`student_average(Student, Res)` - вычисление среднего балла студента по всем предметам. С помощью предиката `findall` ищем оценки студента, а затем при помощи предиката `average(X,T)` вычисляем среднее арифметическое значение элементов списка оценок студента.

`students_average_in_group(Group, R)`- получает средний балл ученика в группе. 

`group_average_print()` - получение таблицы групп и средний балл по каждой из групп, а также печать номера группы и среднего балла для каждой группы. С помощью предиката `findall` создаём список, состоящий из номеров групп. Предикат `sort` упорядочивают список в соответствии со стандартным порядком и одновременно устраняет повторяющиеся элементы. Далее создаем список, который хранит в себе средние баллы студентов из группы, для этого используем предикат `students_average_in_group(Group, R)`. С помощью `average` рассчитываем средний балл группы и выводим его.

Реализация:
```prolog
sum([], 0).
sum([X|Y], S) :-
    sum(Y, Q),
    S is Q + X.

average(X, T) :-
    length(X, L),
    sum(X, P),
    T is P / L.

student_average(Student, R) :-
    findall(N, grade(Student, _, N), List),
    average(List, R).

students_average_in_group(Group, R) :-
    student(Group, Student),
    student_average(Student, R).

group_average_print() :-
    findall(Group, student(Group, _), Glist),
    sort(Glist, List),
    member(Group2, List),
    setof(R, students_average_in_group(Group2, R), ListValue),
    average(ListValue, Answer),
    write('Группа №'), write(Group2), write(' средний балл: '), write(Answer), write('\n'), fail.
```
Пример использования:
```prolog
?- group_average().
Группа №101 средний балл: 3.916666666666667
Группа №102 средний балл: 3.7291666666666665
Группа №103 средний балл: 3.6
Группа №104 средний балл: 3.7916666666666665
false.
```

**2.Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)**

`failed_exam()` - предикат, который вычисляет студентов, не сдавших экзамен и печатает их по каждому предмету. С помощью `subject(X,lesson)` получаем сокращенное название предмета, которое потом нам потребуется для предиката findall. Этот предикат ищет всех студентов, которые не сдали экзамен. С помощью команды `write` печатаем название предмета и фамилии студентов, не сдавших экзамен по этому предмету.

Реализация:
```prolog
failed_exam() :-
    subject(X, S),
    findall(N, grade(N, X, 2), L),
    write(S), write(' не сдали: '), write(L), write('\n'), fail.
```

Пример использования:
```prolog
?- failed_exam().
Логическое программирование не сдали: [Запорожцев,Эфиркина,Текстописов]
Математический анализ не сдали: [Запорожцев,Круглосчиталкин,Густобуквенникова,Криптовалютников,Блокчейнис,Азурин]
Функциональное программирование не сдали: [Криптовалютников]
Информатика не сдали: [Эфиркина,Джаво,Безумников]
Английский язык не сдали: [Эфиркина]
Психология не сдали: [Биткоинов,Текстописова,Криптовалютников,Азурин,Вебсервисов]
false.
```

**3.Найти количество не сдавших студентов в каждой из групп**

Для того, что бы найти количество не сдавших студентов в каждой из групп нужно написать вспомогательные предикаты.
`failed_student(Name,Group)` - находит студентов, которые не сдали экзамен.

`failed_in_group(Group,N)` - предикат, который по запросу номера группы, вычисляет количество не сдавших студентов в этой группе. С помощью предиката `setof` создаем список L, который хранит в себе фамилии студентов, не сдавших экзамен. Вычисляем длину этого списка с помощью предиката `length`

`number_failed()` - предикат, который находит количество не сдавших студентов в каждой из групп. С помощью предиката `findall` создаём список, состоящий из номеров групп. Предикат `sort` упорядочивают список в соответствии со стандартным порядком и одновременно устраняет повторяющиеся элементы. Для каждого значения из списка номеров групп вычисляем количество не сдавших студентов с помощью предиката `failed_in_group(Group,N)`. Выводим номер группы и количество не сдавших студентов в каждой из групп.

Реализация:
```prolog
failed_student(Name,Group) :-
    student(Group,Name),
    grade(Name,_,2).
failed_in_group(Group,N) :-
    setof(X,failed_student(X,Group),L),
    length(L,N).
number_failed():-
    findall(X, student(X, _), Glist),
    sort(Glist, List),
    member(Group, List),
    failed_in_group(Group, N),
    write('Группа: №'), write(Group), write(' не сдали: '), write(N), write('\n'), fail.
```
Пример использования:
```prolog
?- number_failed().
Группа: №101 не сдали: 2
Группа: №102 не сдали: 4
Группа: №103 не сдали: 3
Группа: №104 не сдали: 4
false.
```
## Выводы

Данная лабораторная работа научила меня работать, в первую очередь, с стандартными предикатами обработки списка. Я разобрался с основами языка, списками языка Prolog, написал предикаты обработки чисел списка, поработал с реляционным представлением. Я познакомился с принципами декларативного программирования, которое описывает, что представляет собой проблема и ожидаемый результат, в отличии от императивного, которое описывает, как решить задачу и представить результат. Эта лабораторная заставила меня задуматься, что Prolog - отличный язык для работы с базами данных. В Prolog реляционная база данных представляется в виде набора фактов, что позволяет использовать Prolog, как мощный язык запросов для баз данных. 




